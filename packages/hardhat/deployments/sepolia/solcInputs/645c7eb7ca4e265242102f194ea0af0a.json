{
  "language": "Solidity",
  "sources": {
    "contracts/EnsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * @title EnsRegistry\n * @dev Extract of the interface for ENS Registry\n */\ninterface EnsRegistry {\n\tfunction setOwner(bytes32 node, address owner) external;\n\n\tfunction setSubnodeOwner(\n\t\tbytes32 node,\n\t\tbytes32 label,\n\t\taddress owner\n\t) external;\n\n\tfunction setResolver(bytes32 node, address resolver) external;\n\n\tfunction owner(bytes32 node) external view returns (address);\n\n\tfunction resolver(bytes32 node) external view returns (address);\n}\n"
    },
    "contracts/EnsResolver.sol": {
      "content": "pragma solidity >=0.8.4;\n\n/**\n * @title EnsResolver\n * @dev Extract of the interface for ENS Resolver\n */\ninterface EnsResolver {\n\tfunction setAddr(bytes32 node, address addr) external;\n\n\tfunction addr(bytes32 node) external view returns (address);\n}\n"
    },
    "contracts/EnsSubdomainFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./EnsRegistry.sol\";\nimport \"./EnsResolver.sol\";\n\n/**\n * @title EnsSubdomainFactory\n * @dev Allows to create and configure a subdomain for Ethereum ENS in one call.\n * After deploying this contract, change the owner of the domain you want to use\n * to this deployed contract address. For example, transfer the ownership of \"startonchain.eth\"\n * so anyone can create subdomains like \"radek.startonchain.eth\".\n */\ncontract EnsSubdomainFactory {\n\taddress public owner;\n\taddress public registryAddress;\n\taddress public resolverAddress;\n\tEnsRegistry public registry;\n\tEnsResolver public resolver;\n\tbool public locked;\n\tbytes32 emptyNamehash = 0x00;\n\n\tevent SubdomainCreated(\n\t\taddress indexed creator,\n\t\taddress indexed owner,\n\t\tstring subdomain,\n\t\tstring domain,\n\t\tstring topdomain\n\t);\n\tevent OwnershipTransferred(\n\t\taddress indexed previousOwner,\n\t\taddress indexed newOwner\n\t);\n\tevent RegistryUpdated(\n\t\taddress indexed previousRegistry,\n\t\taddress indexed newRegistry\n\t);\n\tevent ResolverUpdated(\n\t\taddress indexed previousResolver,\n\t\taddress indexed newResolver\n\t);\n\tevent DomainTransfersLocked();\n\n\tconstructor(address _owner, address _registry, address _resolver) {\n\t\towner = _owner;\n\t\tregistry = EnsRegistry(_registry);\n\t\tresolver = EnsResolver(_resolver);\n\t\tregistryAddress = _registry;\n\t\tresolverAddress = _resolver;\n\t\tlocked = false;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t *\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Allows to create a subdomain (e.g. \"radek.startonchain.eth\"),\n\t * set its resolver and set its target address\n\t * @param _subdomain - sub domain name only e.g. \"radek\"\n\t * @param _domain - domain name e.g. \"startonchain\"\n\t * @param _topdomain - parent domain name e.g. \"eth\", \"xyz\"\n\t * @param _owner - address that will become owner of this new subdomain\n\t * @param _target - address that this new domain will resolve to\n\t */\n\tfunction newSubdomain(\n\t\tstring calldata _subdomain,\n\t\tstring calldata _domain,\n\t\tstring calldata _topdomain,\n\t\taddress _owner,\n\t\taddress _target\n\t) public {\n\t\t//create namehash for the topdomain\n\t\tbytes32 topdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\temptyNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_topdomain))\n\t\t\t)\n\t\t);\n\t\t//create namehash for the domain\n\t\tbytes32 domainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\ttopdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_domain))\n\t\t\t)\n\t\t);\n\t\t//make sure this contract owns the domain\n\t\trequire(\n\t\t\tregistry.owner(domainNamehash) == address(this),\n\t\t\t\"this contract should own the domain\"\n\t\t);\n\t\t//create labelhash for the sub domain\n\t\tbytes32 subdomainLabelhash = keccak256(abi.encodePacked(_subdomain));\n\t\t//create namehash for the sub domain\n\t\tbytes32 subdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(domainNamehash, subdomainLabelhash)\n\t\t);\n\t\t//make sure it is free or owned by the sender\n\t\trequire(\n\t\t\tregistry.owner(subdomainNamehash) == address(0) ||\n\t\t\t\tregistry.owner(subdomainNamehash) == msg.sender,\n\t\t\t\"sub domain already owned\"\n\t\t);\n\t\t//create new subdomain, temporarily this smartcontract is the owner\n\t\tregistry.setSubnodeOwner(\n\t\t\tdomainNamehash,\n\t\t\tsubdomainLabelhash,\n\t\t\taddress(this)\n\t\t);\n\t\t//set public resolver for this domain\n\t\tregistry.setResolver(subdomainNamehash, resolverAddress);\n\t\t//set the destination address\n\t\tresolver.setAddr(subdomainNamehash, _target);\n\t\t//change the ownership back to requested owner\n\t\tregistry.setOwner(subdomainNamehash, _owner);\n\n\t\temit SubdomainCreated(\n\t\t\tmsg.sender,\n\t\t\t_owner,\n\t\t\t_subdomain,\n\t\t\t_domain,\n\t\t\t_topdomain\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns the owner of a domain (e.g. \"startonchain.eth\"),\n\t * @param _domain - domain name e.g. \"startonchain\"\n\t * @param _topdomain - parent domain name e.g. \"eth\" or \"xyz\"\n\t */\n\tfunction domainOwner(\n\t\tstring calldata _domain,\n\t\tstring calldata _topdomain\n\t) public view returns (address) {\n\t\tbytes32 topdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\temptyNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_topdomain))\n\t\t\t)\n\t\t);\n\t\tbytes32 namehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\ttopdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_domain))\n\t\t\t)\n\t\t);\n\t\treturn registry.owner(namehash);\n\t}\n\n\t/**\n\t * @dev Return the owner of a subdomain (e.g. \"radek.startonchain.eth\"),\n\t * @param _subdomain - sub domain name only e.g. \"radek\"\n\t * @param _domain - parent domain name e.g. \"startonchain\"\n\t * @param _topdomain - parent domain name e.g. \"eth\", \"xyz\"\n\t */\n\tfunction subdomainOwner(\n\t\tstring calldata _subdomain,\n\t\tstring calldata _domain,\n\t\tstring calldata _topdomain\n\t) public view returns (address) {\n\t\tbytes32 topdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\temptyNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_topdomain))\n\t\t\t)\n\t\t);\n\t\tbytes32 domainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\ttopdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_domain))\n\t\t\t)\n\t\t);\n\t\tbytes32 subdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\tdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_subdomain))\n\t\t\t)\n\t\t);\n\t\treturn registry.owner(subdomainNamehash);\n\t}\n\n\t/**\n\t * @dev Return the target address where the subdomain is pointing to (e.g. \"0x12345...\"),\n\t * @param _subdomain - sub domain name only e.g. \"radek\"\n\t * @param _domain - parent domain name e.g. \"startonchain\"\n\t * @param _topdomain - parent domain name e.g. \"eth\", \"xyz\"\n\t */\n\tfunction subdomainTarget(\n\t\tstring calldata _subdomain,\n\t\tstring calldata _domain,\n\t\tstring calldata _topdomain\n\t) public view returns (address) {\n\t\tbytes32 topdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\temptyNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_topdomain))\n\t\t\t)\n\t\t);\n\t\tbytes32 domainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\ttopdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_domain))\n\t\t\t)\n\t\t);\n\t\tbytes32 subdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\tdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_subdomain))\n\t\t\t)\n\t\t);\n\t\taddress currentResolver = registry.resolver(subdomainNamehash);\n\t\treturn EnsResolver(currentResolver).addr(subdomainNamehash);\n\t}\n\n\t/**\n\t * @dev The contract owner can take away the ownership of any domain owned by this contract.\n\t * @param _node - namehash of the domain\n\t * @param _owner - new owner for the domain\n\t */\n\tfunction transferDomainOwnership(\n\t\tbytes32 _node,\n\t\taddress _owner\n\t) public onlyOwner {\n\t\trequire(!locked);\n\t\tregistry.setOwner(_node, _owner);\n\t}\n\n\t/**\n\t * @dev The contract owner can lock and prevent any future domain ownership transfers.\n\t */\n\tfunction lockDomainOwnershipTransfers() public onlyOwner {\n\t\trequire(!locked);\n\t\tlocked = true;\n\t\temit DomainTransfersLocked();\n\t}\n\n\t/**\n\t * @dev Allows to update to new ENS registry.\n\t * @param _registry The address of new ENS registry to use.\n\t */\n\tfunction updateRegistry(address _registry) public onlyOwner {\n\t\trequire(\n\t\t\tregistryAddress != _registry,\n\t\t\t\"new registry should be different from old\"\n\t\t);\n\t\temit RegistryUpdated(registryAddress, _registry);\n\t\tregistry = EnsRegistry(_registry);\n\t\tregistryAddress = _registry;\n\t}\n\n\t/**\n\t * @dev Allows to update to new ENS resolver.\n\t * @param _resolver The address of new ENS resolver to use.\n\t */\n\tfunction updateResolver(address _resolver) public onlyOwner {\n\t\trequire(\n\t\t\tresolverAddress != _resolver,\n\t\t\t\"new resolver should be different from old\"\n\t\t);\n\t\temit ResolverUpdated(resolverAddress, _resolver);\n\t\tresolver = EnsResolver(_resolver);\n\t\tresolverAddress = _resolver;\n\t}\n\n\t/**\n\t * @dev Allows the current owner to transfer control of the contract to a new owner.\n\t * @param _owner The address to transfer ownership to.\n\t */\n\tfunction transferContractOwnership(address _owner) public onlyOwner {\n\t\trequire(_owner != address(0), \"cannot transfer to address(0)\");\n\t\temit OwnershipTransferred(owner, _owner);\n\t\towner = _owner;\n\t}\n\n\treceive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}