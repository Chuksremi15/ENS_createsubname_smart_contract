{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/EnsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\n/**\n * @title EnsRegistry\n * @dev Extract of the interface for ENS Registry\n */\ninterface EnsRegistry {\n\tfunction setOwner(bytes32 node, address owner) external;\n\n\tfunction setSubnodeOwner(\n\t\tbytes32 node,\n\t\tbytes32 label,\n\t\taddress owner\n\t) external;\n\n\tfunction setResolver(bytes32 node, address resolver) external;\n\n\tfunction owner(bytes32 node) external view returns (address);\n\n\tfunction resolver(bytes32 node) external view returns (address);\n}\n"
    },
    "contracts/EnsResolver.sol": {
      "content": "pragma solidity >=0.8.4;\n\n/**\n * @title EnsResolver\n * @dev Extract of the interface for ENS Resolver\n */\ninterface EnsResolver {\n\tfunction setAddr(bytes32 node, address addr) external;\n\n\tfunction addr(bytes32 node) external view returns (address);\n}\n"
    },
    "contracts/EnsSubdomainFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\nimport \"./EnsRegistry.sol\";\nimport \"./EnsResolver.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\n/**\n * @title EnsSubdomainFactory\n * @dev Allows to create and configure a subdomain for Ethereum ENS in one call.\n * After deploying this contract, change the owner of the domain you want to use\n * to this deployed contract address. For example, transfer the ownership of \"startonchain.eth\"\n * so anyone can create subdomains like \"radek.startonchain.eth\".\n */\ncontract EnsSubdomainFactory is ERC1155Holder {\n\taddress public owner;\n\taddress public registryAddress;\n\taddress public resolverAddress;\n\tEnsRegistry public registry;\n\tEnsResolver public resolver;\n\tbool public locked;\n\tbytes32 emptyNamehash = 0x00;\n\n\tevent SubdomainCreated(\n\t\taddress indexed creator,\n\t\taddress indexed owner,\n\t\tstring subdomain,\n\t\tstring domain,\n\t\tstring topdomain\n\t);\n\tevent OwnershipTransferred(\n\t\taddress indexed previousOwner,\n\t\taddress indexed newOwner\n\t);\n\tevent RegistryUpdated(\n\t\taddress indexed previousRegistry,\n\t\taddress indexed newRegistry\n\t);\n\tevent ResolverUpdated(\n\t\taddress indexed previousResolver,\n\t\taddress indexed newResolver\n\t);\n\tevent DomainTransfersLocked();\n\n\tconstructor(address _owner, address _registry, address _resolver) {\n\t\towner = _owner;\n\t\tregistry = EnsRegistry(_registry);\n\t\tresolver = EnsResolver(_resolver);\n\t\tregistryAddress = _registry;\n\t\tresolverAddress = _resolver;\n\t\tlocked = false;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t *\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Allows to create a subdomain (e.g. \"radek.startonchain.eth\"),\n\t * set its resolver and set its target address\n\t * @param _subdomain - sub domain name only e.g. \"radek\"\n\t * @param _domain - domain name e.g. \"startonchain\"\n\t * @param _topdomain - parent domain name e.g. \"eth\", \"xyz\"\n\t * @param _owner - address that will become owner of this new subdomain\n\t * @param _target - address that this new domain will resolve to\n\t */\n\tfunction newSubdomain(\n\t\tstring calldata _subdomain,\n\t\tstring calldata _domain,\n\t\tstring calldata _topdomain,\n\t\taddress _owner,\n\t\taddress _target\n\t) public {\n\t\t//create namehash for the topdomain\n\t\tbytes32 topdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\temptyNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_topdomain))\n\t\t\t)\n\t\t);\n\t\t//create namehash for the domain\n\t\tbytes32 domainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\ttopdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_domain))\n\t\t\t)\n\t\t);\n\t\t//make sure this contract owns the domain\n\t\trequire(\n\t\t\tregistry.owner(domainNamehash) == address(this),\n\t\t\t\"this contract should own the domain\"\n\t\t);\n\t\t//create labelhash for the sub domain\n\t\tbytes32 subdomainLabelhash = keccak256(abi.encodePacked(_subdomain));\n\t\t//create namehash for the sub domain\n\t\tbytes32 subdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(domainNamehash, subdomainLabelhash)\n\t\t);\n\t\t//make sure it is free or owned by the sender\n\t\trequire(\n\t\t\tregistry.owner(subdomainNamehash) == address(0) ||\n\t\t\t\tregistry.owner(subdomainNamehash) == msg.sender,\n\t\t\t\"sub domain already owned\"\n\t\t);\n\t\t//create new subdomain, temporarily this smartcontract is the owner\n\t\tregistry.setSubnodeOwner(\n\t\t\tdomainNamehash,\n\t\t\tsubdomainLabelhash,\n\t\t\taddress(this)\n\t\t);\n\t\t//set public resolver for this domain\n\t\tregistry.setResolver(subdomainNamehash, resolverAddress);\n\t\t//set the destination address\n\t\tresolver.setAddr(subdomainNamehash, _target);\n\t\t//change the ownership back to requested owner\n\t\tregistry.setOwner(subdomainNamehash, _owner);\n\n\t\temit SubdomainCreated(\n\t\t\tmsg.sender,\n\t\t\t_owner,\n\t\t\t_subdomain,\n\t\t\t_domain,\n\t\t\t_topdomain\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns the owner of a domain (e.g. \"startonchain.eth\"),\n\t * @param _domain - domain name e.g. \"startonchain\"\n\t * @param _topdomain - parent domain name e.g. \"eth\" or \"xyz\"\n\t */\n\tfunction domainOwner(\n\t\tstring calldata _domain,\n\t\tstring calldata _topdomain\n\t) public view returns (address) {\n\t\tbytes32 topdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\temptyNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_topdomain))\n\t\t\t)\n\t\t);\n\t\tbytes32 namehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\ttopdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_domain))\n\t\t\t)\n\t\t);\n\t\treturn registry.owner(namehash);\n\t}\n\n\t/**\n\t * @dev Return the owner of a subdomain (e.g. \"radek.startonchain.eth\"),\n\t * @param _subdomain - sub domain name only e.g. \"radek\"\n\t * @param _domain - parent domain name e.g. \"startonchain\"\n\t * @param _topdomain - parent domain name e.g. \"eth\", \"xyz\"\n\t */\n\tfunction subdomainOwner(\n\t\tstring calldata _subdomain,\n\t\tstring calldata _domain,\n\t\tstring calldata _topdomain\n\t) public view returns (address) {\n\t\tbytes32 topdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\temptyNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_topdomain))\n\t\t\t)\n\t\t);\n\t\tbytes32 domainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\ttopdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_domain))\n\t\t\t)\n\t\t);\n\t\tbytes32 subdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\tdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_subdomain))\n\t\t\t)\n\t\t);\n\t\treturn registry.owner(subdomainNamehash);\n\t}\n\n\t/**\n\t * @dev Return the target address where the subdomain is pointing to (e.g. \"0x12345...\"),\n\t * @param _subdomain - sub domain name only e.g. \"radek\"\n\t * @param _domain - parent domain name e.g. \"startonchain\"\n\t * @param _topdomain - parent domain name e.g. \"eth\", \"xyz\"\n\t */\n\tfunction subdomainTarget(\n\t\tstring calldata _subdomain,\n\t\tstring calldata _domain,\n\t\tstring calldata _topdomain\n\t) public view returns (address) {\n\t\tbytes32 topdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\temptyNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_topdomain))\n\t\t\t)\n\t\t);\n\t\tbytes32 domainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\ttopdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_domain))\n\t\t\t)\n\t\t);\n\t\tbytes32 subdomainNamehash = keccak256(\n\t\t\tabi.encodePacked(\n\t\t\t\tdomainNamehash,\n\t\t\t\tkeccak256(abi.encodePacked(_subdomain))\n\t\t\t)\n\t\t);\n\t\taddress currentResolver = registry.resolver(subdomainNamehash);\n\t\treturn EnsResolver(currentResolver).addr(subdomainNamehash);\n\t}\n\n\t/**\n\t * @dev The contract owner can take away the ownership of any domain owned by this contract.\n\t * @param _node - namehash of the domain\n\t * @param _owner - new owner for the domain\n\t */\n\tfunction transferDomainOwnership(\n\t\tbytes32 _node,\n\t\taddress _owner\n\t) public onlyOwner {\n\t\trequire(!locked);\n\t\tregistry.setOwner(_node, _owner);\n\t}\n\n\t/**\n\t * @dev The contract owner can lock and prevent any future domain ownership transfers.\n\t */\n\tfunction lockDomainOwnershipTransfers() public onlyOwner {\n\t\trequire(!locked);\n\t\tlocked = true;\n\t\temit DomainTransfersLocked();\n\t}\n\n\t/**\n\t * @dev Allows to update to new ENS registry.\n\t * @param _registry The address of new ENS registry to use.\n\t */\n\tfunction updateRegistry(address _registry) public onlyOwner {\n\t\trequire(\n\t\t\tregistryAddress != _registry,\n\t\t\t\"new registry should be different from old\"\n\t\t);\n\t\temit RegistryUpdated(registryAddress, _registry);\n\t\tregistry = EnsRegistry(_registry);\n\t\tregistryAddress = _registry;\n\t}\n\n\t/**\n\t * @dev Allows to update to new ENS resolver.\n\t * @param _resolver The address of new ENS resolver to use.\n\t */\n\tfunction updateResolver(address _resolver) public onlyOwner {\n\t\trequire(\n\t\t\tresolverAddress != _resolver,\n\t\t\t\"new resolver should be different from old\"\n\t\t);\n\t\temit ResolverUpdated(resolverAddress, _resolver);\n\t\tresolver = EnsResolver(_resolver);\n\t\tresolverAddress = _resolver;\n\t}\n\n\t/**\n\t * @dev Allows the current owner to transfer control of the contract to a new owner.\n\t * @param _owner The address to transfer ownership to.\n\t */\n\tfunction transferContractOwnership(address _owner) public onlyOwner {\n\t\trequire(_owner != address(0), \"cannot transfer to address(0)\");\n\t\temit OwnershipTransferred(owner, _owner);\n\t\towner = _owner;\n\t}\n\n\treceive() external payable {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}